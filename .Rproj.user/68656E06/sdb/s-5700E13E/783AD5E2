{
    "collab_server" : "",
    "contents" : "\nlibrary(\"rlist\")\n\nparseSifToDataModel <- function(sif){\n  Links<-c()\n  FinalNodes <- c()\n  proteins <- c()\n  smallA <- list()\n  smallB <- list()\n  participProteinA <- c()\n  participProteinB <- c()\n  usedToProducePA <- c()\n  usedToProducePB <- list()\n  reactWithPA<-c()\n  reactWithPB<-list()\n  neighbor_of<-list()\n  controlReaction <- c()\n  #Metadatos para almacenamiento de links\n  source <- c()\n  target <- c()\n  tipoLink <- c()\n  Links <- data.frame()\n  #Control de fosforilaicon\n  controlPhospho <- c()\n  counterPhospho <- 1\n  proteinChangePhosphoA <- c()\n  phosphoChangeProteinB <- c()\n  #Contorl de estado\n  controlState <- c()\n  stateChangeProteinsB <- c()\n  proteinsChangeStateA <- c()\n  counterControlState <- 1\n  #contorl expresion of\n  controlExpresion <- c()\n  counterExpresion <- 1\n  expresionProteins <- c()\n  #chemical-affects\n  controlChemicalAffects <- c()\n  counterChemical <- 1\n  chemicalProteins <- c()\n  chemicalSM <- c()\n  \n  in_complex_Proteins <- c()\n  interactsProteins <- c()\n  #Lectura del sif y sus relaciones\n  for(i in c(1:length(sif$INTERACTION_TYPE))){\n    switch(sif$INTERACTION_TYPE[i],\n           \"chemical-affects\" ={\n             P <- sif$PARTICIPANT_B[i]\n             SM <- sif$PARTICIPANT_A[i]\n             if(!any(chemicalProteins == P)){\n               chemicalProteins <- c(chemicalProteins, P)\n             }\n             if(!any(chemicalSM == SM)){\n               chemicalSM <- c(chemicalSM, SM)\n             }\n             controlChemicalAffects <- c(controlChemicalAffects, paste(\"control_chemical\", counterChemical))\n             posCOUNT <- controlChemicalAffects[counterChemical]\n             source <- c(source, SM)\n             target <- c(target, posCOUNT)\n             tipoLink <- c(tipoLink, \"controlOf\")\n             \n             source<- c(source, P)\n             target <- c(target, posCOUNT)\n             tipoLink <- c(tipoLink, \"imputLink\")\n             \n             source <- c(source, posCOUNT)\n             target <- c(target, paste(P,\"_chem_Affects\"))\n             tipoLink <- c(tipoLink, \"outputLink\")\n             counterChemical = counterChemical + 1 \n           },\n            \"interacts-with\" = {\n              PA <- sif$PARTICIPANT_A[i]\n              PB <- sif$PARTICIPANT_B[i]\n              interactsProteins <- c(interactsProteins, PA, PB)\n              source <- c(source, PA)\n              target <- c(target, PB)\n              tipoLink <- c(tipoLink, \"molecule_interaction\")\n            }\n           ,\"in-complex-with\" = {\n             PA <- sif$PARTICIPANT_A[i]\n             PB <- sif$PARTICIPANT_B[i]\n             in_complex_Proteins <- c(in_complex_Proteins, PA, PB)\n             source <- c(source, PA)\n             target <- c(target, PB)\n             tipoLink <- c(tipoLink, \"in_complexLink\")\n             \n           }\n           ,\n           \"controls-expression-of\" = {\n             if(!any(expresionProteins==sif$PARTICIPANT_A[i])){\n               expresionProteins <- c(expresionProteins, sif$PARTICIPANT_A[i])\n             }\n             if(!any(expresionProteins==sif$PARTICIPANT_B[i])){\n               expresionProteins <- c(expresionProteins, sif$PARTICIPANT_B[i])\n             }\n             controlExpresion <- c(controlExpresion, paste(\"control_expression\", counterExpresion))\n             source <- c(source, sif$PARTICIPANT_A[i])\n             target <- c(target, controlExpresion[counterExpresion])\n             tipoLink <- c(tipoLink, \"controlOf\")\n             \n             source <- c(source, controlExpresion[counterExpresion])\n             target <- c(target, sif$PARTICIPANT_B[i])\n             tipoLink <- c(tipoLink, \"outputLink\")\n             counterExpresion = counterExpresion + 1\n           },\n           \"controls-phosphorylation-of\" = {\n             if(!any(proteinChangePhosphoA == sif$PARTICIPANT_A[i])){\n\n               proteinChangePhosphoA <- c(proteinChangePhosphoA, sif$PARTICIPANT_A[i])\n             }\n             if(!any(phosphoChangeProteinB == sif$PARTICIPANT_B[i])){\n               phosphoChangeProteinB <- c(phosphoChangeProteinB, sif$PARTICIPANT_B[i])\n             }\n             controlPhospho <- c(controlPhospho, paste(\"phospho_control\", counterPhospho))\n             #añadimos enlace proteina entrante->control\n             source <- c(source, sif$PARTICIPANT_B[i])\n             target <- c(target, controlPhospho[counterPhospho])\n             tipoLink <- c(tipoLink, \"imputLink\")\n             #añadimos enlace proteinaControl->contorl\n             source <- c(source, sif$PARTICIPANT_A[i])\n             target <- c(target, controlPhospho[counterPhospho])\n             tipoLink <- c(tipoLink, \"controlOf\")\n             #añadimos enlace control->proteinaPhospho\n             source <- c(source, controlPhospho[counterPhospho])\n             target <- c(target, paste(sif$PARTICIPANT_B[i],\"_P\"))\n             tipoLink <- c(tipoLink, \"outputLink\")\n             \n             counterPhospho <- counterPhospho + 1\n           },\n           \"controls-state-change-of\" = { \n             #añadimos el enlace proteina inicial->control\n             if (!any(stateChangeProteinsB==sif$PARTICIPANT_B[i])){\n               stateChangeProteinsB <- c(stateChangeProteinsB, sif$PARTICIPANT_B[i])\n             }\n             if (!any(proteinsChangeStateA==sif$PARTICIPANT_A[i])){\n               proteinsChangeStateA <- c(proteinsChangeStateA, sif$PARTICIPANT_A[i])\n             }\n             controlState <- c(controlState, paste(\"controlState\",counterControlState))\n             source <- c(source, sif$PARTICIPANT_B[i])\n             target <- c(target, controlState[counterControlState])\n             tipoLink <- c(tipoLink, \"imputLink\")\n             #añadimos el enlace proteinaControl->control\n             source <- c(source, sif$PARTICIPANT_A[i])\n             target <- c(target, controlState[counterControlState])\n             tipoLink <- c(tipoLink, \"controlOf\")\n             #añadimos el enlace control->proteina final\n             source <- c(source, controlState[counterControlState])\n             target <- c(target, paste(sif$PARTICIPANT_B[i],\"_STATE_CHANGE\"))\n             tipoLink <- c(tipoLink, \"outputLink\")\n             \n             counterControlState <- counterControlState + 1\n           },\n           \"consumption-controlled-by\"={\n             SM <- sif$PARTICIPANT_A[i]\n             length(smallA)<-length(proteins)\n             \n             if (!any(proteins==sif$PARTICIPANT_B[i])){\n               proteins <- c(proteins, sif$PARTICIPANT_B[i])\n               smallA <- c(smallA,SM)\n               \n             }else{\n               posP <- grep(sif$PARTICIPANT_B[i], proteins)\n               \n               smallA[[posP]] <- c(smallA[[posP]],SM)\n             }\n             length(smallB)<-length(proteins)\n           },\n         \"controls-production-of\"={\n             SM <- sif$PARTICIPANT_B[i]\n             length(smallB)<-length(proteins)\n             if (!any(proteins==sif$PARTICIPANT_A[i])){\n               proteins <- c(proteins, sif$PARTICIPANT_A[i])\n               smallB <- c(smallB,SM)\n               \n             }else{\n               posP <- grep(sif$PARTICIPANT_A[i], proteins)\n               smallB[[posP]] <- c(smallB[[posP]],SM)\n             }\n             length(smallA)<-length(proteins)\n             \n           },\n           \n           \"catalysis-precedes\" ={\n             \n             participProteinA <- c(participProteinA, sif$PARTICIPANT_A[i])\n             participProteinB <- c(participProteinB, sif$PARTICIPANT_B[i])\n           },\n           \n           \"used-to-produce\" ={\n             PA <- sif$PARTICIPANT_A[i]\n             PB <- sif$PARTICIPANT_B[i]\n             \n             if(any(usedToProducePA == PA)){\n               posPA<-grep(PA, usedToProducePA, fixed = T)\n               \n               usedToProducePB[[max(posPA)]] <- c(usedToProducePB[[max(posPA)]],PB)\n             }else{\n               usedToProducePA<-c(usedToProducePA,PA)\n               usedToProducePB<-c(usedToProducePB,PB)\n               length(usedToProducePB)<-length(usedToProducePA)\n             }\n             \n           },\n           \"reacts-with\" ={\n             PA <- sif$PARTICIPANT_A[i]\n             PB <- sif$PARTICIPANT_B[i]\n             \n             if(any(reactWithPA == PA)){\n               posPA<-grep(PA, reactWithPA, fixed = T)\n               \n               reactWithPB[[max(posPA)]] <- c(reactWithPB[[max(posPA)]],PB)\n             }else{\n               reactWithPA<-c(reactWithPA,PA)\n               reactWithPB<-c(reactWithPB,PB)\n               length(reactWithPB)<-length(reactWithPB)\n             }\n           }\n    )\n  }\n  #Nos quedamos con las proteinas vecinas\n  length(neighbor_of) <- length(proteins)\n   #Para numerar el numero de reacciones de cambios de estado\n  for(i in c(1:length(sif$INTERACTION_TYPE))){\n    switch(sif$INTERACTION_TYPE[i],\n           \"neighbor-of\" ={\n             \n             if (!any(proteins==sif$PARTICIPANT_A[i])){\n               proteins <- c(proteins, sif$PARTICIPANT_A[i])\n             }\n             if (!any(proteins==sif$PARTICIPANT_B[i])){\n               proteins <- c(proteins, sif$PARTICIPANT_B[i])\n             }\n             length(neighbor_of) <- length(proteins)\n             posPA<-grep(sif$PARTICIPANT_A[i], proteins, fixed = F)\n             posPB<-grep(sif$PARTICIPANT_B[i], proteins, fixed = F)\n             neighbor_of[[posPA]]<-c(neighbor_of[[posPA]], proteins[posPB])\n             neighbor_of[[posPA]]<-c(neighbor_of[[posPA]], proteins[posPA])\n             neighbor_of[[posPA]]<-unique(neighbor_of[[posPA]])\n           })\n  }\n  \n  #Quedarnos con los conjuntos de vecinos que se autoengloban\n  Final_neighbor_of<-list()\n  for(i in c(1:(length(neighbor_of)-1))){\n    length(Final_neighbor_of)<-length(neighbor_of)\n    for(j in c((i+1):(length(neighbor_of)))){\n      \n      trueVector <- match(neighbor_of[[j]],neighbor_of[[i]])\n      trueVector <- trueVector[!is.na(trueVector)]\n      trueVectorL <- length(trueVector)\n      if(length(neighbor_of[[j]])>length(neighbor_of[[i]]) && trueVectorL == length(neighbor_of[[i]])){\n        Final_neighbor_of[[i]]<-neighbor_of[[j]]\n      }else if(length(neighbor_of[[i]])>length(neighbor_of[[j]]) && trueVectorL == length(neighbor_of[[j]]) &&\n               length(Final_neighbor_of[[i]])<length(neighbor_of[[i]])){\n        Final_neighbor_of[[i]]<-neighbor_of[[i]]\n      }\n    }\n  }\n  Final_neighbor_of <-list.clean(unique(Final_neighbor_of), fun = is.null, recursive = TRUE) \n  \n  Finalproteins <- list()\n  \n  #Una vez tenemos el conjunto de vecinos que se autoengloban creamos una lista de proteinas finales\n  #Tendremos una entrada en esta lista por cada conjunto de vecinos y por cada proteina que no pertenezca a ningún conjunto\n  Finalproteins<-Final_neighbor_of\n  for(P in proteins){\n    containsConfirm <- F\n    for(FN in Finalproteins){\n      \n      if(any(FN==P)){\n        containsConfirm<-T\n        break\n      }\n    }\n    if(!containsConfirm){\n      Finalproteins <- c(Finalproteins, P)\n    }\n  }\n  #Finalsmall\n  FinalsmallA <- list()\n  length(FinalsmallA) <- length(Finalproteins)\n  FinalsmallB <- list()\n  length(FinalsmallB) <- length(Finalproteins)\n  #print(Finalproteins)\n  #print(FinalsmallB)\n  \n  for(i in c(1:length(proteins))){\n    for(j in c(1:length(Finalproteins))){\n      if(any(Finalproteins[[j]]==proteins[i])){\n        FinalsmallA[[j]]<-c(FinalsmallA[[j]],smallA[[i]])\n        FinalsmallB[[j]]<-c(FinalsmallB[[j]],smallB[[i]])\n        \n      }\n    }\n  }\n  #Limpieza Moleculas\n  for(i in c(1:length(Finalproteins))){\n    FinalsmallA[[i]]<-unique(FinalsmallA[[i]])\n    FinalsmallB[[i]]<-unique(FinalsmallB[[i]])\n  }\n  \n  #Cambiamos el nombre de las proteinas que han sufrido un cambio de estado y aprovechamos para añadir algunos nodos\n  \n  for (i in c(1:length(Finalproteins))){\n    NP<-Finalproteins[[i]]\n    for(j in c(1:length(NP))){\n      if(any(stateChangeProteinsB==NP[j])){\n        Finalproteins[[i]][j]<-paste(NP[j],\"_STATE_CHANGE\")\n      }\n      if(any(phosphoChangeProteinB == NP[j])){\n        Finalproteins[[i]][j]<-paste(NP[j],\"_P\")\n      }\n      if(any(chemicalProteins == NP[j])){\n        Finalproteins[[i]][j]<-paste(NP[j],\"_chem_Affects\")\n      }\n    }\n  }\n  \n  #Creación inicial de links\n  for(i in c(1:length(Finalproteins))){\n    controlReaction <- c(controlReaction, paste(\"controlReaction\",i))\n    for(P in Finalproteins[[i]]){\n      source <- c(source, P)\n      target <- c(target, controlReaction[i])\n      tipoLink <- c(tipoLink, \"controlOf\")\n    }\n    for(SM in FinalsmallA[[i]]){\n      source <- c(source, SM)\n      target <- c(target, controlReaction[i])\n      tipoLink <- c(tipoLink, \"imputLink\")\n    }\n    for(SM in FinalsmallB[[i]]){\n      source <- c(source, controlReaction[i])\n      target <- c(target, SM)\n      tipoLink <- c(tipoLink, \"outputLink\")\n    }\n  }\n  Links <- data.frame(source,tipoLink,target)\n  ProteinNodes<-c()\n  ProteinNodes <- unique(unlist(list(Finalproteins, stateChangeProteinsB, \n                                     proteinsChangeStateA, controlReaction, controlState,\n                                     proteinChangePhosphoA, phosphoChangeProteinB, controlPhospho, \n                                     expresionProteins, controlExpresion, chemicalProteins, controlChemicalAffects\n                                     , in_complex_Proteins, interactsProteins)))\n  smNodes <- c()\n  smNodes <- unique(unlist(list(FinalsmallA, FinalsmallB, chemicalSM)))\n  FinalNodes <- nodeSet(ProteinNodes, smNodes)\n  return(c(Links,FinalNodes))\n  \n}\n\nnodeSet <- function(ProteinNodes, smNodes){\n  #Metadatos para almacenamiento de nodos\n  tipoNodo <- c()\n  nodos<- c()\n  FinalNodes <- data.frame()\n\n  for(P in ProteinNodes){\n    if(length(grep(\"_STATE_CHANGE\",P))!=0){\n      nodos <- c(nodos, P)\n      tipoNodo <- c(tipoNodo, \"state_change\")\n    }else if(length(grep(\"control\",P))!=0){\n      nodos<- c(nodos, P)\n      tipoNodo <- c(tipoNodo, \"control\")\n    }else if(length(grep(\"_P\", P))!=0){\n      nodos <- c(nodos, P)\n      tipoNodo <- c(tipoNodo, \"withP\")\n    }else{\n      nodos <- c(nodos, P)\n      tipoNodo <- c(tipoNodo, \"NProt\")\n    }\n  }\n  for(SM in smNodes){\n    nodos <- c(nodos, SM)\n    tipoNodo <- c(tipoNodo, \"NSM\")\n  }\n  \n  \n  FinalNodes <- data.frame(nodos, tipoNodo)\n  return(FinalNodes)\n}\n\n\n",
    "created" : 1516296698945.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3174971651",
    "id" : "783AD5E2",
    "lastKnownWriteTime" : 1516298005,
    "last_content_update" : 1516298005454,
    "path" : "C:/Users/cesar/Dropbox/Cuarto/Estándares/Rpath/rpath_app/FinalParseSif.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}